## 알고리즘 문제 풀기 with Python 

### 스택

Last In First Out

push(data) : 맨 위에 데이터 쌓기
pop() : 맨 위의 데이터 꺼내기
peek() : 맨 위의 데이터 보기
isEmpty() : 스택이 비어있는지 확인하기

**Linked List로 Stack 구현하기**

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class Stack:
    def __init__(self):
        self.head = None

    def push(self, value):
        new_node = Node(value)
        new_node.next = self.head
        self.head = new_node
        return

    def pop(self):
        if self.is_empty():
            return "Stack is Empty"
        node = self.head
        self.head = self.head.next
        return node

    def peek(self):
        if self.is_empty():
            return "Stack is Empty"
        return self.head

    def is_empty(self):
        return self.head is None

stack = Stack()
stack.push(1)
stack.push(2)
stack.push(3)
print(stack.is_empty())
print(stack.peek())
print(stack.pop())
print(stack.pop())
print(stack.pop())
print(stack.pop())
print(stack.is_empty())
```

Stack을 직접 구현해봤지만 python에서는 보통 list를 사용한다.

**top 문제**

```python
top_heights = [6, 9, 5, 7, 4]


 #
 #
 # #
## #
#####
#####
#####
#####
#####

def get_receiver_top_orders(heights):
    length = len(heights)
    result = [0] * length

    for i in range(length - 1):
        target = heights.pop()
        for j in range(len(heights)):
            if heights[len(heights) - 1 - j] >= target:
                result[length - 1 - i] = len(heights) - j
                break
    return result


print(get_receiver_top_orders(top_heights))  # [0, 0, 2, 2, 4] 가 반환되어야 한다!
```



### 큐

First In First Out

현실 세계의 대기열과 유사하다. (실제로 많은 대기열 시스템의 로직 구조가 큐로 되어있다.)

enqueue(data): 맨 아래에 데이터 추가하기
dequeue() : 맨 위의 데이터 추출하기
peek() : 맨 위의 데이터 보기
isEmpty() : 큐가 비어있는지 확인하기

**Linked List로 Queue 구현하기**

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class Queue:
    def __init__(self):
        self.head = None
        self.tail = None

    def enqueue(self, value):
        if self.is_empty():
            self.head = Node(value)
            self.tail = self.head
        else:
            new_node = Node(value)
            self.tail.next = new_node
            self.tail = new_node
        return

    def dequeue(self):
        if self.is_empty():
            return "Queue is Empty"
        else:
            node = self.head
            self.head = self.head.next
            return node.data

    def peek(self):
        if self.is_empty():
            return "Queue is Empty"
        else:
            return self.head.data

    def is_empty(self):
        return self.head is None


queue = Queue()
queue.enqueue(1)
queue.enqueue(2)
queue.enqueue(3)
queue.enqueue(4)
print(queue.is_empty())
print(queue.peek())
print(queue.dequeue())
print(queue.dequeue())
print(queue.dequeue())
print(queue.dequeue())
print(queue.dequeue())
print(queue.is_empty())
```



### 해쉬



