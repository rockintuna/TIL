## 이펙티브 자바, 아이템 8. finalizer와 cleaner 사용을 피하라

자바의 두가지 객체 소멸자 finalizer, cleaner

- **finalizer (자바9 deprecated)**
  finalizer는 예측할 수 없고, 상황에 따라 위험할 수 있어서 일반적으로 불필요하다. 기본적으로 쓰지말아야 한다.
- **cleaner**
  cleaner는 finalizer보다는 덜 위험하지만, 여전히 예측할 수 없고, 느리고, 일반적으로 불필요하다.
- **finalizer와 cleaner의 문제점**
  - finalizer, cleaner가 예측할 수 없다는 것은, 객체에 접근할 수 없게 된 후 finalizer나 cleaner가 실행되기까지 얼마나 걸릴지 알 수 없다는 것.
    즉, finalizer와 cleaner로는 제때 실행되어야 하는 작업은 절대 할 수 없다.
  - finalizer와 cleaner는 수행 여부를 보장하지 않는다. 객체 종료 작업을 수행하지 못한 채 프로그램이 중단될 수 있다. 때문에 데이터베이스 같이 상태를 영구적으로 수정하는 작업에서는 절대 finalizer나 cleaner에 의존해서는 안된다.
  - finalizer는 동작 중에 발생하는 예외를 무시해버린다. 잡지 못한 예외 때문에 객체가 홰손된 상태로 남을 수 있다.
  - finalizer와 cleaner는 심각한 성능 문제도 동반한다. finalizer와 cleaner는 가비지 컬렉터의 효율을 떨어뜨린다.
  - finalizer를 사용하면 finalizer 공격에 노출되어 심각한 보안 문제를 일으킬 수도 있다. 

- **finalizer와 cleaner의 대안**
  AutoCloseable을 구현하고 클라이언트에서 인스턴스를 다 쓰고 나면 close 메서드를 호출하는 것(일반적으로 예외가 발생해도 제대로 종료되도록 try-with-resources를 사용)
- **finalizer와 cleaner의 적절한 쓰임새**
  - 자원의 소유자가 close 메서드를 호출하지 않는 것에 대비한 안전망 역할
  - 네이티브 피어와 연결된 객체 회수
    - 네이티브 피어 : 일반 자바 객체가 네이티브 메서드를 통해 기능을 위임한 네이티브 객체.
    - 네이티브 피어는 가비지 컬렉터가 식별할 수 없다.
- **핵심 정리**
  finalizer와 cleaner는 안전망 역할이나 중요하지 않은 네이티브 자원 회수용으로만 사용하자. 하지만 이런 경우라도 불확실성과 성능 저하에 주의해야 한다.



## 클린 코드, 8. 경계

소프트웨어 경계(제공자가 제공하고 사용자는 사용하는 인터페이스)를 깔끔하게 처리하는 기법과 기교.

- **외부 코드 사용하기**
  Map과 같은 경계 인터페이스를 이용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다. (Map 객체를 가지고 있는 새로운 클래스를 만들어서 대신 사용하기) Map 인스턴스를 공개 API의 인수로 넘기거나 반환값으로 사용하지 않는다.
- **경계 살피고 익히기**
  외부 코드를 익히고 우리의 프로그램과 통합하는 것은 어렵다. '학습테스트'는 곧바로 우리쪽 코드를 작성해 외부 코드를 호출하는 뻔한 방식 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익힌다. 
- **학습 테스트는 공짜 이상이다**
  학습 테스트는 드는 비용 없이 필요한 지식만 확보하는 손쉬운 방법이다.
  학습 테스트는 공짜 이상이다. 투자하는 노력보다 얻는 성과가 더 크다. 새로운 버전이 우리 코드와 호완되지 않으면 학습 테스트가 이 사실을 곧바로 밝혀낸다.
- **아직 존재하지 않는 코드를 사용하기**
  아직 정의되지 않은 API를 실제로 사용할 우리의 코드와 분리한다. 우리에게 필요한 인터페이스를 만들어두었다가 나중에 외부 API가 정의되면 그 때 ADAPTER 패턴으로 API 사용을 캡슐화하면서 인터페이스를 구현한 Adapter를 만든다.
- **깨끗한 경계**
  외부 패키지가 변했을 때 경계 변경 비용이 지나치게 커지지 않도록 각별히 주의해야 한다.
  경계에 위치하는 코드는 깔끔히 분리한다. 또한 기대치를 정의하는 테스트 케이스도 작성한다. 통제가 불가능한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 훨씬 좋다.
  외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자. 새로운 클래스로 경계를 감싸거나 ADAPTER 패턴을 사용해 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환하자.

