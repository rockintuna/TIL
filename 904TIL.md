### 이펙티브 자바, 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

**상속을 고려한 설계와 문서화가 뜻하는 것.**

- **상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.**
  상속용 클래스의 메서드에서 자신의 다른 메서드를 호출할 수도 있는데(자기사용) 호출되는 메서드가 재정의될 수 있다면 클래스를 상속하여 메서드를 재정의할 때 문제가 발생할 수 있다. 때문에 자기사용에 대한 내용을 API 설명에 적시해야 한다. 
  백그라운드 스레드나 정적 초기화 과정에서도 메서드가 호출되어 자기사용이 발생할 수 있다.
  @implSpec 어노테이션은 자바독 도구가 API문서에 Implementation Requirements로 시작하는 메서드 내부 동작 방식 설명을 추가해준다.
- **클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.**
  protected는 내부 구현에 해당하지만 노출하여 재정의 되었을 때 얻을 수 있는 강점(성능 개선 등)이 있다면 노출한다.
  그렇지만 역시 내부 구현에 해당하므로 그 수는 가능한 적어야 한다.
  직접 하위 클래스를 만들어서 테스트하면서 필요한 protected 메서드나 멤버를 찾는 것이 최선이다.
- **상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.**
- **상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.**
  하위 클래스 생성에서 의도치 않게 하위 클래스의 메서드가 호출될 수 있다. 하위 클래스 인스턴스가 초기화되기 전에 메서드가 먼저 호출되어 버리므로 충분히 프로그램 문제가 발생할 수 있다.
  `private`, `final`, `static` 메서드는 재정의할 수 없는 메서드이므로 안심하고 호출할 수 있다.
- **Cloneable과 Serializable을 하나라도 구현한 클래스는 확장하려는 프로그래머에게 부담을 주게 되므로 상속용 설계로 바람직하지 않다.**
  하위 클래스에서 구현 하도록 하는 방법도 있다.
  clone과 readObject 메서든는 생성자와 비슷한 효과를 가지는데, 생성자 처럼 재정의 가능 메서드를 호출해서는 안된다.
  Serializable을 구현한 상속용 클래스의 readResolve와 writeReplace 메서드는 protected로 선언해야 한다.
- **상속용으로 설계하지 않은 클래스는 상속을 금지시킨다.**
  일반적인 콘크리트 클래스를 상속받는 경우 상위 클래스의 변경에 하위 클래스가 받는 영향을 예측하기 어렵다.
  가장 쉬운 방법은 final 클래스로 만들기.
  또는 모든 생성자를 private 또는 package-private으로 만들고 정적 팩토리를 제공하기.



### 이펙티브 자바, 아이템 20. 추상 클래스보다는 인터페이스를 우선하라

**인터페이스를 우선해야 하는 이유**

- **추상 클래스를 구현하려면 추상 클래스를 상속해야 한다. 자바는 단일 상속만 지원하므로 이 방식은 새로운 타입을 정의하는 데 커다란 제약을 안게 된다.**
- **인터페이스는 기존 클래스에서 손쉽게 구현해넣을 수 있다.**
- **인터페이스는 믹스인(mixin) 정의에 안성맞춤이다.**
  mixin : 클래스가 구현할 수 있는 타입, 믹스인을 구현한 클래스에 원래의 '주된 타입'외에 특정 선택적 행위를 제공한다고 선언하는 효과를 준다. (ex Comparable, Serializable, ...)
  추상 클래스는 위에 나온 제약 때문에 믹스인을 정의할 수 없다.
- **인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다.**
  계층을 엄격히 구분하기 어려운 개념을 여러 인터페이스를 구현함으로써 해결할 수 있다.
  추상 클래스에서는 조합 폭발 현상이 발생한다.
- **인터페이스를 래퍼 클래스와 함께 사용하면 기능을 향상시키는 안전하고 강력한 수단이 된다.**
  상속해서 만든 클래스는 래퍼 클래스보다 활용도가 떨어지고 깨지기는 더 쉽다.
- **디폴트 메서드를 사용할 수 있게 되었다.**
  주의사항 : equals와 hashCode 같은 Object 메서드는 디폴트 메서드로 제공하면 안 된다.

**템플릿 메서드 패턴**
인터페이스와 추상 골격 구현 클래스를 함께 제공한다.
관례상 추상 골격 구현 클래스 이름은 "Abstract"+인터페이스이름 (ex AbstractCollection, AbstractSet, AbstractList, AbstractMap, ...)
인터페이스로는 타입을 정의하고 추상 클래스 또는 인터페이스인 골격 구현 클래스에서는 타입이 되는 인터페이스에 정의된 메서드를 구현한다.
**단순히 골격 구현 클래스만 확장하면 인터페이스를 구현하는 일이 대부분 완료된다.**
구조상 골격 구현을 확장하지 못하는 경우에는 인터페이스를 구현한 상태에서 골격 구현 클래스를 확장한 내부 클래스의 인스턴스에 메서드 호출을 전달한다(시뮬레이드한 다중 상속, simulated multiple inheritance). 다중 상속의 많은 장점을 제공하면서 단점은 피하게 해준다.
주의사항 : 골격 구현 클래스는 상속용 클래스로 가정되므로 설계 및 문서화 지침을 따라야 한다.

**단순 구현**
골격 구현의 작은 변종으로 추상 클래스가 아니다. 즉, 동작하는 가장 단순한 구현이다. 
골격 구현 클래스와 다르게 그냥 그대로 쓸 수 있다.
