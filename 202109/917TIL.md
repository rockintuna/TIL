### 항해99 DAY 6

- try-catch 문에서 실행부를 제외한 catch 블록이 동일한 코드로 자주 사용됩니다. 중복을 없앨 수 있을까요?

  ```python
  @app.route('/post', methods=['DELETE'])
  def delete_post():
      token_receive = request.cookies.get('mytoken')
  
      try:
          #jwt에서 payload 가져오기
          payload = jwt.decode(token_receive, SECRET_KEY, algorithms=['HS256'])
          
          #payload를 통해 user 정보 조회
          user = db.users.find_one({"user_id": payload["user_id"]})
  
          post_id_receive = request.form['post_id']
          post_id_valid_check(post_id_receive)
          if is_post_owner(post_id_receive, user):
              db.post.delete_one({'_id': ObjectId(post_id_receive)})
              db.comment.delete_many({'post_id': post_id_receive})
              db.likes.delete_many({'post_id': post_id_receive})
              return jsonify({'msg': '고민이 삭제되었습니다.'})
          else:
              return jsonify({'msg': '해당 글에 대한 권한이 없습니다.'}), 403
  
      # 예외 처리
      # token 만료 예외
      except jwt.ExpiredSignatureError:
          msg = '로그인 시간이 만료되었습니다.'
          return render_template('error/401.html', msg=msg), 401
      # 유효하지 않은 token 예외
      except jwt.DecodeError:
          msg = '로그인 정보가 존재하지 않습니다.'
          return render_template('error/401.html', msg=msg), 401
  ```

- 해결, 훨씬 깔끔하다.

  ```python
  @app.route('/post', methods=['DELETE'])
  def delete_post():
      token_receive = request.cookies.get('mytoken')
      user = get_user_from_token(token_receive)
  
      post_id_receive = request.form['post_id']
      post_id_valid_check(post_id_receive)
      if is_post_owner(post_id_receive, user):
          db.post.delete_one({'_id': ObjectId(post_id_receive)})
          db.comment.delete_many({'post_id': post_id_receive})
          db.likes.delete_many({'post_id': post_id_receive})
          return jsonify({'msg': '고민이 삭제되었습니다.'})
      else:
          return jsonify({'msg': '해당 글에 대한 권한이 없습니다.'}), 403
  
  # ExpiredSignatureError 및 DecodeError 가 발생하는 곳이 jwt.decode 이므로 요부문만 추출한다.
  # get_user_from_token()는 유저 정보가 필요한 다른 메서드들에서 공통적으로 사용하면 된다.
  def get_user_from_token(token):
      try:
          payload = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])
          user = db.users.find_one({"user_id": payload["user_id"]})
          return user
      except jwt.ExpiredSignatureError:
          msg = '로그인 시간이 만료되었습니다.'
          return render_template('error/401.html', msg=msg), 401
      except jwt.DecodeError:
          msg = '로그인 정보가 존재하지 않습니다.'
          return render_template('error/401.html', msg=msg), 401
  ```




### 자바 람다식

분명히 난 자바 스터디할때 람다에 대해서 공부를 했다. 근데 왜 어떤게 머리속에 들어가면 GC마냥 다른 안쓰는 것은 삭제되는 것인가.
오늘은 '잊혀진' 람다에 대해서 다시 공부해보고 조금 다른 공부 방법을 써보려고 한다. 사실 방법이랄것도 없다 그냥 겁나 두들겨 보는거다.

일단 자바 8하면 떠오르는 **람다식**.. 도덕책 언제쓰일까?
람다식은 익히 알듯이 익명 함수이다. 
익명 함수라는 말은 부를 이름이 없다는 말이다. 
부를 이름이 없다는 것은 다음에 또 불러서 쓰일 수 없다는 말이다.
즉, 람다식은 이번에 한번만 쓸 메서드를 좀 더 간결하게 만들고 싶을때 사용한다.

심지어 람다식은 



