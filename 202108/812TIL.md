## 이펙티브 자바, 아이템 4. 인스턴스화를 막으려거든 private 생성자를 사용하라

정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한 게 아니다. 그러나 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어 주기 때문에 private 생성자를 추가하여 클래스의 인스턴스화를 막을 수 있다.

명시적인 생성자를 추가하면 기본 생성자가 자동으로 만들어지지 않으며, 명시적인 생성자가 private이므로 클래스 바깥에서는 접근할 수 없다. 코드에 인스턴스화 방지용이라는 주석을 추가하는 것도 좋다. 

생성자가 private 생성자 하나만 있는 경우에는 하위 클래스의 생성자에서 사용될 상위클래스 생성자가 없는 것이므로 상속도 막을 수 있다.



## 이펙티브 자바, 아이템 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

하나 이상의 자원에 의존하는 클래스가 있다. 예를들어 아래 SpellChecker 클래스는 dictionary에 의존한다.

```java
public class SpellChecker {
    private static final Lexicon dictionary = ...;
    public static boolean isValid(String word){
        //...
    }
}
```

예시에서는 인스턴스화를 막고 정적 유틸리티 클래스로 만들었는데, 이런 경우 dictionary를 단 하나만 사용한다고 가정해야 하기 때문에 여러가지 dictionary를 써야한다면 잘못된 방법이다. 싱글턴으로 만들어도 같은 문제가 생긴다.

그렇다면 자원의 final을 제거하고 자원을 제어할 수 있는 메서드를 만든다면?

```java
public class SpellChecker {
    private static Lexicon dictionary = ...;

    public static void setDictionary(Lexicon dictionary) {
        this.dictionary = dictionary;
    }
    public static boolean isValid(String word){
        //...
    }
}
```

이런 방식은 어색하고 오류를 내기 쉬우며 Thread-safe 하지 않다. 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다.

클래스가 여러 자원 인스턴스를 지원하고 클라이언트가 원하는 자원을 사용하도록 하기 위해 의존 객체 주입 방식으로 만들 수 있다.
인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식이다.

```java
public class SpellChecker {
    private final Lexicon dictionary;
    
    public SpellChecker(Lexicon dictionary) {
        this.dictionary = Objects.requireNonNull(dictionary);
    }
    public boolean isValid(String word){
        //...
    }
}
```

의존 객체 주입 방식은 제어 메서드를 따로 사용하는 것 보다 단순하고 Thread-safe 하다는 장점이 있다. 

이 패턴의 쓸만한 변형으로, 생성자에 자원 팩토리(팩토리란 호출할 때마다 특정 타입의 인스턴스를 반복해서 만들어주는 객체)를 넘겨주는 방식이 있다. (팩토리 메서드 패턴)
`Supplier<T>`가 팩토리를 표현한 완벽한 예이다. `Supplier<T>`를 입력으로 받는 메서드는 와일드 카드 타입을 사용하여 팩토리의 타입 매개변수를 제한할 수 있다.

```java
public class Moszic {
    private Tile tile;

    private Moszic(Tile tile) {
        this.tile = tile;
    }

    public static Moszic create(Supplier<? extends Tile> tileFactory) {
        return new Moszic(tileFactory.get());
    }
}
```

예를들어 클라이언트가 제공한 팩토리(Supplier)가 생성한 타일들로 구성된 모자이크를 만든다.

```java
        Supplier<Tile> supplier = CheckTile::new;
        Moszic.create(supplier);
```



의존 객체 주입이 유연성과 테이스 용이성을 개선해주지만, 큰 프로젝트에서는 오히려 코드를 어지럽게 만든다. 의존 객체 주입 프레임워크(대거, 주스, 스프링)을 사용하여 어질러짐을 해결할 수 있다.



- 핵심정리
  클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱들턴과 정적 유틸리티 클래스는 적합하지 않다. 이 자원들을 클래스가 직접 만들게 해서도 안된다. 
  대신 필요한 자원을 (혹은 그 자원을 만들어주는 팩토리를)생성자에 넘겨주는 의존 객체 주입 기법을 사용하자. 클래스의 유연성, 재사용성, 테스트 용이성을 개선해준다.



## 클린 코드, 5. 형식 맞추기

프로그래머라면 형식을 깔끔하게 맞춰 코드를 짜야 한다.

- 형식을 맞추는 목적
  의사소통은 전문 개발자의 일차적인 의무이며 코드 형식은 의사소통의 일환이다.
- 적절한 행 길이를 유지하라.
  일반적으로 큰 파일보다 작은 파일이 이해하기 쉽다.
  - 신문 기사처럼 작성하라.
    이름은 간단하면서도 설명이 가능하게, 첫 부분은 고차원 개념과 알고리즘을 설명 내려갈수록 저차원 함수와 세부 내역.
  - 개념은 빈 행으로 분리하라.
    빈 행은 새로운 개념을 시작한다는 시각적 단서다. 완결된 생각하나를 행 묶음으로 표현하고 생각 사이에 빈 행을 넣어 분리한다.
  - 세로 밀집도
    서로 밀접한 코드 행은 세로로 가까이 놓여야 한다.
  - 수직 거리
    서로 밀접한 개념은 세로로 가까이 둬야 한다. 연관성이 깊은 두 개념이 멀리 떨어져 있으면 코드를 읽는 사람이 소스 파일과 클래스를 여기저기 뒤지게 된다.
- 변수 선언
  변수는 사용되는 위치에 최대한 가까이 선언한다. 지역 변수는 각 함수 맨 처음에 선언한다.
- 인스턴스 변수
  인스턴스 변수는 클래스 맨 처음에 선언한다.
- 종속 함수
  한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다. 가능하다면 호출하는 함수를 먼저(위에) 배치한다.
- 개념적 유사성
  비슷한 동작을 수행하는 일군의 함수들을 가까이 배치한다.
- 가로 형식 맞추기
  짧은 행이 바람직하다. 왠만하면 120자 내로.
  - 가로 공백과 밀집도
    가로 공백으로 두 가지 요소를 나누고 공백을 넣지 않으면 밀집도를 높여준다.
    ex) `int lineSize = line.length();`
    ex) `b*b - 4*a*c`
  - 가로 정렬
    가로 정렬은 엉뚱한 부분을 강조해서 진짜 의도가 가려질 수 있다.
  - 들여쓰기
    계층에서 코드가 자리잡은 수준에 비례하여 들여쓰기 한다.
- 팀 규칙
  팀에 속한다면 팀 규칙에 합의하고 모든 팀원들이 그 규칙을 따라야 소프트웨어가 일관적인 스타일을 보인다.
  온갖 스타일을 뒤섞어 소스 코드를 필요 이상으로 복잡하게 만드는 실수는 반드시 피해야한다.