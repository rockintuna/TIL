## 이펙티브 자바, 아이템 7. 다 쓴 객체 참조를 해제하라

자바의 가비지 컬렉터는 다 쓴 객체를 알아서 회수해가지만 그렇다고 메모리 관리에 더 이상 신경 쓰지 않아도 되는 것은 아니다.
가비지 컬렉션 언어에서는 메모리 누수를 찾기가 아주 까다롭다. 객체 참조 하나를 살려두면 가비지 컬렉터는 그 객체뿐아니라 그 객체가 참조하는 모든 객체를 회수해가지 못한다. 그래서 단 몇 개의 객체가 매우 많은 객체를 회수되지 못하게 할 수 있고 잠재적으로 성능에 악영향을 줄 수 있다.

해법은 참조해제. 해당 참조를 다 썼을 때 null 처리하면 된다. 

```java
    public Object pop() {
        if (size == 0) {
            throw new EmptyStackException();
        }
        Object result = elements[--size];
        elements[--size] = null; // 다 쓴 객체 참조 해제
        return result;
    }
```

- 객체 참조를 null 처리하는 일은 스택처럼 자기 메모리를 직접 관리하는 클래스에서 처럼 예외적인 경우여야 한다. 참조 해제의 가장 좋은 방법은 그 참조를 담은 변수를 유효 범위 밖으로 밀어내는 것이다. 

- **캐시**
  캐시 역시 메모리 누수를 일으키는 주범이다. 
  캐시 외부에서 키를 참조하는 동안만 엔트리가 살아 있는 캐시가 필요한 상황이라면 WeakHashMap를 사용해 캐시를 만들자. 다 쓴 엔트리는 자동으로 제거된다.
  보통 캐시 엔트리의 유효 기간을 정의하기 어려우므로 시간이 지날수록 엔트리의 가치를 떨어뜨리는 방식을 사용한다. 이런 방식에서는 쓰지 않는 엔트리를 이따금 청소해줘야 하는데, 백그라운드 스레드를 활용하거나 새 엔트리를 추가할 때 부수 작업으로 수행하는 방법(예를 들어 LinkedHashMap의 removeEldestEntry 메서드)이 있다.
- **리스너 혹은 콜백**
  클라이언트가 콜백을 등록만 하고 명확히 해지하지 않는다면 콜백은 계속 쌓여갈 것이다. 이럴 때 콜백을 약한 참조로 저장하면 가비지 컬렉터가 즉시 수거해간다. 예를들어 WeakHashMap에 키로 저장하면 된다.

- **핵심 정리**
  메모리 누수는 찾기 어려우므로 예방법을 익혀두는 것이 매우 중요하다.



## 클린 코드, 7. 오류 처리

오류 처리는 중요하지만 오류 처리 코드로 인해 프로그램 로직을 이해하기 어려워진다면 깨끗한 코드라 부르기 어렵다.

- 오류 코드보다 예외를 사용하라
  오류 플래그를 설정하거나 호출자에게 오류 코드를 반환하는 방식의 함수는 호출한 즉시 오류를 확인해야 하기 때문에 호출자 코드가 복잡해진다. 대신 예외를 던지면 로직이 오류 처리 코드와 뒤섞이지 않으니까 호출자 코드가 깔끔해진다. 
- Try-Catch-Finally 문부터 작성하라
  예외가 발생할 코드를 짤 때 try-catch-finally 문부터 코딩을 시작하면 try 블록에서 무슨 일이 생기든지 호출자가 기대하는 상태를 정의하기 쉬워진다.  먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법을 권장한다. 그러면 자연스럽게 try블록의 트랜잭션 범위부터 구현하게 되므로 범위 내에서 트랜잭션 본질을 유지하기 쉬워진다.
- 미확인 예외(Unchecked Exception)를 사용하라
  확인된 예외(Checked Exception)가 주는 몇가지 장점(안정성 등)이 그 비용(OCP 위반, 하위 단계의 함수에서 예외를 반환하고 상위 단계에서 예외를 처리한다면 그 중간에 있는 모든 메서드의 선언부에 해당 예외를 정의해야 한다.)에 비해서 이익을 제공하지 못할 수 있다. 일반적인 애플리케이션은 의존성이라는 비용이 이익보다 크다.
- 예외에 의미를 제공하라
  예외를 던질 때는 전후 상황을 충분히 덧붙여서(오류메시지 등으로 충분한 정보 넘기기) 실패한 코드의 의도를 파악하기 쉽도록 하자.
- 호출자를 고려해 예외 클래스를 정의하라
  애플리케이션에서 오류를 정의할 때 프로그래머에게 가장 중요한 관심사는 오류를 잡아내는 방법이 되어야 한다. 메서드에서 여러 예외 유형의 예외 처리 방식이 동일하다면 하나의 예외 유형을 대신 반환할 클래스로 감싸서 코드를 깨끗하게 할 수 있다. 또한 외부 API를 감싸면 외부 라이브러리와 프로그램 사이의 의존성이 크게 줄어들고 감싸기 클래스에서 외부 API를 호출하는 대신 테스트 코드를 넣어주는 방법으로 테스트도 하기 쉬워진다. 그리고 특정 업체가 API를 설계한 방식에 발목잡히지 않게 된다. 

- 정상 흐름을 정의하라
  때로는 중단이 적합하지 않은 때도 있다. 이럴때는 예외를 처리하는 대신 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식, 특수 사례 패턴을 사용한다.
- null을 반환하지 마라
  null을 반환하는 코드는 일거리를 늘릴 뿐만 아니라 호출자에게 문제를 떠넘긴다. null 확인을 빼먹는 것은 문제다. 하지만 null 확인을 너무 많이 하는 것 또한 문제다. 메서드에서 null을 반환하고픈 유혹이 든다면 그 대신 예외를 던지거나 특수 사례 패턴 객체를 반환한다. 사용하는 외부 API가 null을 반환한다면 감싸기 클래스를 구현해서 해결한다.
- null을 전달하지 마라
  정삭적인 인수로 null을 기대하는 API가 아니라면 메서드로 null을 전달하는 코드는 최대한 피한다. 대다수 프로그래밍 언어는 호출자가 실수로 넘기는 null을 적절히 처리하는 방법이 없다. 그렇다면 애초에 null을 넘기지 못하도록 금지하는 정책이 합리적이다.
- 결론
  오류 처리를 프로그램 로직과 분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있다. 오류 처리를 프로그램 로직과 분리하면 독립적인 추론이 가능해지며 코드 유지보수성도 크게 높아진다. 
